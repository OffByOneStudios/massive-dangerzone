
## Modules

Modules are the key insight of MADZ. Modules are data. Some of the data in modules often describes the rest of the data (typically called metadata). This is a simple concept that is not often correctly used. For example, operating systems and file systems fail in the ability to reason about the files they manage as, consequently, do many of the applications which run on them. The are unable to build reasonable identities and relationships between data, or allow applications to do the same.

Recently data as the core structure of applications has become popular, [Entity-Component-Systems](http://en.wikipedia.org/wiki/Entity_component_system) being a common example, although there are others [0](http://www.chris-granger.com/2013/01/24/the-ide-as-data/). Think of modules as a way to describe existing data in a context which can be consumed by systems designed around data.

We believe we can use these concepts to build a better way to talk about, and consequently, use data. Specifically the data used to program things.

### Bootstrapping

As MADZ is self hosting, that is it's own data is contained within modules, we will always require a way to know something about something, a basis from which we can build other data. For now we will build a large, monolithic, bootstrapper within the python language.

Later the bootstrapper will be much simpler, likely autogenerated, with a reduced feature set, to be able to load only whats immediately necessary.

### Ontological Classification

Modules are ontological in nature, that is they can be of many different kinds at once. Some of these classifications may be spelled out by the metadata, others may be generated by the MADZ system from analysis of the data, or implied consequence of the metadata.

This means that a module could simultanesouly describe many disparate things, typically this is a bad design choice if it is on purpose, better to describe one thing and let the ontological system determine what else it can describe. For example a module may contain python code implementing a runtime feature, from this the MADZ system may determine that it can also describe a website hosting the documentation of that code, but for the module to attempt to spell that out is not a proper design.

### All data is a Module

Eventually MADZ will be able to reason about all data as a module. Including user generated data. MADZ is a system for managing modules, whatever they may be.

Consider what MADZ could do with a collection of photos as a module. It could replicate the data to different backup services, or to public image hosting, it could tag people, run computer vision algorithms, etc. And it will know how to do these operations because it has some context (the metadata) for the collection of data in question.

Consider what MADZ could do with a folder of unclassified user data, it could automatically organize that data into modules (or create a UI for that purpose), and assign context to them by placing them into modules.

In the other direction, data is still organized in modules. When we create some object files from some source code module we place them in a new temporary module which describes to MADZ when it generated them, from where it generated them, and how it generated them.

### Why not files?

Well current file organizational systems are not conducive to being used this way. Eventually it may be useful to store modules as singular files, and require some program to view them, but then the point is that the storage medium doesn't matter.

### What does MADZ really get me?

To an extent this sounds like every program ever written. We modify data, we present user interfaces, etc. But MADZ is a way to organize everything within your project in such a way that it is easier to reason about. It's a toolkit for building better applications, and then manipulating them.
